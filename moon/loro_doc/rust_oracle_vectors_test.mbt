///|
/// Seq-CRDT convergence tests (Rust as oracle).
///
/// This file embeds a small set of FastUpdates(mode=4) blobs exported from Rust Loro,
/// and asserts MoonBit `LoroDoc.import` converges to the same deep JSON.
///
/// Regenerate vectors:
///   `cargo run -p moon-vectors-gen`
struct RustOracleVectorCase {
  name : String
  updates_hex : Array[String]
  expected_json : String
  expected_text_delta_json : String?
}

fn hex_nibble(c : UInt16) -> Int {
  let x = c.to_int()
  if x >= '0'.to_int() && x <= '9'.to_int() {
    x - '0'.to_int()
  } else if x >= 'a'.to_int() && x <= 'f'.to_int() {
    10 + (x - 'a'.to_int())
  } else if x >= 'A'.to_int() && x <= 'F'.to_int() {
    10 + (x - 'A'.to_int())
  } else {
    abort("invalid hex char")
  }
}

fn hex_to_bytes(hex : String) -> Bytes {
  if hex.length() % 2 != 0 {
    abort("invalid hex length")
  }
  let out_len = hex.length() / 2
  Bytes::makei(out_len, i => {
    let hi = hex_nibble(hex[2 * i])
    let lo = hex_nibble(hex[2 * i + 1])
    ((hi << 4) | lo).to_byte()
  })
}

fn reversed_copy(xs : Array[String]) -> Array[String] {
  let out : Array[String] = []
  for i in 0..<xs.length() {
    out.push(xs[xs.length() - 1 - i])
  }
  out
}

// Generated by `cargo run -p moon-vectors-gen`
let rust_oracle_vectors : Array[RustOracleVectorCase] = [
  {
    name: "concurrent_list_insert_same_pos",
    updates_hex: [
      "6c6f726f000000000000000000000000710ca4d3000440000100010110010100000000000000010100000000000501000001000601040101000005046c697374000e010402010002010002010b02010100050701050141",
      "6c6f726f0000000000000000000000005f11419f000440000100010110010200000000000000010100000000000501000001000601040101000005046c697374000e010402010002010002010b02010100050701050142",
    ],
    expected_json: "{\"list\":[\"A\",\"B\"]}",
    expected_text_delta_json: None,
  },
  {
    name: "concurrent_text_insert_same_pos",
    updates_hex: [
      "6c6f726f000000000000000000000000ce1879d900043d0001000101100101000000000000000101000000000005010000010006010401020000050474657874000e010402010002010002010502010100020141",
      "6c6f726f0000000000000000000000003dd6e32b00043d0001000101100102000000000000000101000000000005010000010006010401020000050474657874000e010402010002010002010502010100020142",
    ],
    expected_json: "{\"text\":\"AB\"}",
    expected_text_delta_json: Some("[{\"insert\":\"AB\"}]"),
  },
  {
    name: "concurrent_list_insert_vs_delete",
    updates_hex: [
      "6c6f726f0000000000000000000000000c2900bf000451000300030110010100000000000000010100000000000501000001000601040101000005046c697374001101040204000303000203030b09030302010b0103020100020102020102080702050141050142",
      "6c6f726f000000000000000000000000c063d653000443000200020110010100000000000000010100000000000501000001000601040101000005046c697374000e010402010002010002010b020102000807020501410501424b00010201011b0202000000000000000100000000000000010101010101020000000501000001000601040101000005046c697374000e010402010002010202010b02010100050701050158",
    ],
    expected_json: "{\"list\":[\"A\",\"X\"]}",
    expected_text_delta_json: None,
  },
  {
    name: "concurrent_text_insert_vs_delete",
    updates_hex: [
      "6c6f726f0000000000000000000000003a1db5f900044c0003000301100101000000000000000101000000000005010000010006010401020000050474657874001101040204000303000203030509030302010b010302010002010202010203024142",
      "6c6f726f0000000000000000000000008439c67300043e0002000201100101000000000000000101000000000005010000010006010401020000050474657874000e010402010002010002010502010200030241424800010201011b02020000000000000001000000000000000101010101010200000005010000010006010401020000050474657874000e010402010002010202010502010100020158",
    ],
    expected_json: "{\"text\":\"AX\"}",
    expected_text_delta_json: Some("[{\"insert\":\"AX\"}]"),
  },
  {
    name: "concurrent_movable_list_insert_same_pos",
    updates_hex: [
      "6c6f726f00000000000000000000000013d953b800043e000100010110010100000000000000010100000000000501000001000601040104000003026d6c000e010402010002010002010b02010100050701050141",
      "6c6f726f000000000000000000000000a785a24400043e000100010110010200000000000000010100000000000501000001000601040104000003026d6c000e010402010002010002010b02010100050701050142",
    ],
    expected_json: "{\"ml\":[\"A\",\"B\"]}",
    expected_text_delta_json: None,
  },
  {
    name: "concurrent_movable_list_move_same_elem",
    updates_hex: [
      "6c6f726f000000000000000000000000a16cd5c700044a000400040110010100000000000000010100000000000501000001000601040104000003026d6c001101040204000303000403030b0e03030301000e0703050161050162050163000000",
      "6c6f726f000000000000000000000000df138a0d000444000300030110010100000000000000010100000000000501000001000601040104000003026d6c000e010402010002010002010b020103000b07030501610501620501634700010301011b0202000000000000000100000000000000010101010101040000000501000001000601040104000003026d6c000e010402010002010202010e0201010003000100",
    ],
    expected_json: "{\"ml\":[\"b\",\"a\",\"c\"]}",
    expected_text_delta_json: None,
  },
  {
    name: "concurrent_movable_list_set_same_elem",
    updates_hex: [
      "6c6f726f0000000000000000000000003e798f29000444000200020110010100000000000000010100000000000501000001000601040104000003026d6c000f010402040002040003030b0f020401000a07010501610000050178",
      "6c6f726f00000000000000000000000020f251b700043e000100010110010100000000000000010100000000000501000001000601040104000003026d6c000e010402010002010002010b020101000507010501614900010101011b0202000000000000000100000000000000010101010101000000000501000001000601040104000003026d6c000e010402010002010002010f02010100050100050179",
    ],
    expected_json: "{\"ml\":[\"y\"]}",
    expected_text_delta_json: None,
  },
  {
    name: "concurrent_richtext_bold_mark_vs_insert_end",
    updates_hex: [
      "6c6f726f000000000000000000000000e8a5462f00044e00070007011001010000000000000001010000000000050100000100060104010200020a04626f6c640474657874001201040206000206000405050c000401050401000a0548656c6c6f84050001",
      "6c6f726f00000000000000000000000076fe88920004410005000501100101000000000000000101000000000005010000010006010401020000050474657874000e010402010002010002010502010500060548656c6c6f4e00070507011b02020000000000000001000000000000000101010101010800000005010000010006010401020000050474657874000e010402010002010a02010502010700080720576f726c6421",
    ],
    expected_json: "{\"text\":\"Hello World!\"}",
    expected_text_delta_json: Some("[{\"attributes\":{\"bold\":true},\"insert\":\"Hello\"},{\"insert\":\" World!\"}]"),
  },
  {
    name: "concurrent_richtext_link_mark_vs_insert_end",
    updates_hex: [
      "6c6f726f000000000000000000000000c403250300044e00070007011001010000000000000001010000000000050100000100060104010200020a046c696e6b0474657874001201040206000206000405050c000401050401000a0548656c6c6f80050001",
      "6c6f726f00000000000000000000000076fe88920004410005000501100101000000000000000101000000000005010000010006010401020000050474657874000e010402010002010002010502010500060548656c6c6f4e00070507011b02020000000000000001000000000000000101010101010800000005010000010006010401020000050474657874000e010402010002010a02010502010700080720576f726c6421",
    ],
    expected_json: "{\"text\":\"Hello World!\"}",
    expected_text_delta_json: Some("[{\"attributes\":{\"link\":true},\"insert\":\"Hello\"},{\"insert\":\" World!\"}]"),
  },
]

///|
fn run_rust_oracle_case(c : RustOracleVectorCase) -> Unit raise Error {
  let expected = @json.parse(c.expected_json.view()) catch {
    _ => fail("invalid expected_json for case: " + c.name)
  }
  let expected_text_delta =
    match c.expected_text_delta_json {
      None => None
      Some(s) =>
        Some(@json.parse(s.view()) catch { _ => fail("invalid expected_text_delta_json: " + c.name) })
    }

  let doc1 = LoroDoc::new()
  doc1.setPeerId(999UL) catch {
    err => fail("case " + c.name + ": setPeerId failed: " + err.to_string())
  }
  for h in c.updates_hex {
    doc1.importBytes(hex_to_bytes(h)) catch {
      err => fail("case " + c.name + ": importBytes failed: " + err.to_string())
    }
  }
  let got1 = doc1.toJSON()
  if got1 != expected {
    fail(
      "case " +
      c.name +
      ": doc1 toJSON mismatch, vv=" +
      doc1.oplogVersion().to_string() +
      " got=" +
      got1.to_string() +
      " expected=" +
      expected.to_string(),
    )
  }
  match expected_text_delta {
    None => ()
    Some(delta) => {
      let t = doc1.getText("text") catch {
        err => fail("case " + c.name + ": getText failed: " + err.to_string())
      }
      assert_eq(t.toDelta(), delta)
    }
  }

  let doc2 = LoroDoc::new()
  doc2.setPeerId(1000UL) catch {
    err => fail("case " + c.name + ": setPeerId failed: " + err.to_string())
  }
  for h in reversed_copy(c.updates_hex) {
    doc2.importBytes(hex_to_bytes(h)) catch {
      err => fail("case " + c.name + ": importBytes failed: " + err.to_string())
    }
  }
  let got2 = doc2.toJSON()
  if got2 != expected {
    fail(
      "case " +
      c.name +
      ": doc2 toJSON mismatch, vv=" +
      doc2.oplogVersion().to_string() +
      " got=" +
      got2.to_string() +
      " expected=" +
      expected.to_string(),
    )
  }
  match expected_text_delta {
    None => ()
    Some(delta) => {
      let t = doc2.getText("text") catch {
        err => fail("case " + c.name + ": getText failed: " + err.to_string())
      }
      assert_eq(t.toDelta(), delta)
    }
  }
}

///|
test "rust oracle: concurrent_list_insert_same_pos" {
  run_rust_oracle_case(rust_oracle_vectors[0])
}

///|
test "rust oracle: concurrent_text_insert_same_pos" {
  run_rust_oracle_case(rust_oracle_vectors[1])
}

///|
test "rust oracle: concurrent_list_insert_vs_delete" {
  run_rust_oracle_case(rust_oracle_vectors[2])
}

///|
test "rust oracle: concurrent_text_insert_vs_delete" {
  run_rust_oracle_case(rust_oracle_vectors[3])
}

///|
test "rust oracle: concurrent_movable_list_insert_same_pos" {
  run_rust_oracle_case(rust_oracle_vectors[4])
}

///|
test "rust oracle: concurrent_movable_list_move_same_elem" {
  run_rust_oracle_case(rust_oracle_vectors[5])
}

///|
test "rust oracle: concurrent_movable_list_set_same_elem" {
  run_rust_oracle_case(rust_oracle_vectors[6])
}

///|
test "rust oracle: concurrent_richtext_bold_mark_vs_insert_end" {
  run_rust_oracle_case(rust_oracle_vectors[7])
}

///|
test "rust oracle: concurrent_richtext_link_mark_vs_insert_end" {
  run_rust_oracle_case(rust_oracle_vectors[8])
}

///|
test "codec: multi-peer fastupdates includes peer2 changes" {
  // `updates_b` for insert-vs-delete cases includes the imported base (peer=1)
  // plus a local change from peer=2. Ensure the codec sees both peers.
  let c = rust_oracle_vectors[2] // concurrent_list_insert_vs_delete
  let bytes = hex_to_bytes(c.updates_hex[1])
  let doc = @loro_codec.parse_document(bytes, true) catch {
    _ => fail("parse_document failed")
  }
  let blocks = @loro_codec.parse_fast_updates_body(doc.body_view()) catch {
    _ => fail("parse_fast_updates_body failed")
  }
  let mut has_peer2 = false
  for b in blocks {
    let decoded = @loro_codec.decode_change_block_full(b) catch {
      _ => fail("decode_change_block_full failed")
    }
    for ch in decoded.changes() {
      if ch.id().peer() == 2UL {
        has_peer2 = true
        assert_eq(ch.deps().length(), 1)
        assert_eq(ch.deps()[0].peer(), 1UL)
        assert_eq(ch.deps()[0].counter(), 1)
      }
    }
  }
  assert_true(has_peer2)
}
