///|
/// Seq-CRDT convergence tests (Rust as oracle).
///
/// This file embeds a small set of FastUpdates(mode=4) blobs exported from Rust Loro,
/// and asserts MoonBit `LoroDoc.import` converges to the same deep JSON.
///
/// Regenerate vectors:
///   `cargo run -p moon-vectors-gen`
struct RustOracleVectorCase {
  name : String
  updates_hex : Array[String]
  expected_json : String
}

fn hex_nibble(c : UInt16) -> Int {
  let x = c.to_int()
  if x >= '0'.to_int() && x <= '9'.to_int() {
    x - '0'.to_int()
  } else if x >= 'a'.to_int() && x <= 'f'.to_int() {
    10 + (x - 'a'.to_int())
  } else if x >= 'A'.to_int() && x <= 'F'.to_int() {
    10 + (x - 'A'.to_int())
  } else {
    fail("invalid hex char")
  }
}

fn hex_to_bytes(hex : String) -> Bytes {
  if hex.length() % 2 != 0 {
    fail("invalid hex length")
  }
  let out_len = hex.length() / 2
  Bytes::makei(out_len, i => {
    let hi = hex_nibble(hex[2 * i])
    let lo = hex_nibble(hex[2 * i + 1])
    ((hi << 4) | lo).to_byte()
  })
}

fn reversed_copy(xs : Array[String]) -> Array[String] {
  let out : Array[String] = []
  for i in 0..<xs.length() {
    out.push(xs[xs.length() - 1 - i])
  }
  out
}

// Generated by `cargo run -p moon-vectors-gen`
let RUST_ORACLE_VECTORS : Array[RustOracleVectorCase] = [
  {
    name: "concurrent_list_insert_same_pos",
    updates_hex: [
      "6c6f726f000000000000000000000000710ca4d3000440000100010110010100000000000000010100000000000501000001000601040101000005046c697374000e010402010002010002010b02010100050701050141",
      "6c6f726f0000000000000000000000005f11419f000440000100010110010200000000000000010100000000000501000001000601040101000005046c697374000e010402010002010002010b02010100050701050142",
    ],
    expected_json: "{\"list\":[\"A\",\"B\"]}",
  },
  {
    name: "concurrent_text_insert_same_pos",
    updates_hex: [
      "6c6f726f000000000000000000000000ce1879d900043d0001000101100101000000000000000101000000000005010000010006010401020000050474657874000e010402010002010002010502010100020141",
      "6c6f726f0000000000000000000000003dd6e32b00043d0001000101100102000000000000000101000000000005010000010006010401020000050474657874000e010402010002010002010502010100020142",
    ],
    expected_json: "{\"text\":\"AB\"}",
  },
  {
    name: "concurrent_list_insert_vs_delete",
    updates_hex: [
      "6c6f726f0000000000000000000000000c2900bf000451000300030110010100000000000000010100000000000501000001000601040101000005046c697374001101040204000303000203030b09030302010b0103020100020102020102080702050141050142",
      "6c6f726f000000000000000000000000c063d653000443000200020110010100000000000000010100000000000501000001000601040101000005046c697374000e010402010002010002010b020102000807020501410501424b00010201011b0202000000000000000100000000000000010101010101020000000501000001000601040101000005046c697374000e010402010002010202010b02010100050701050158",
    ],
    expected_json: "{\"list\":[\"A\",\"X\"]}",
  },
  {
    name: "concurrent_text_insert_vs_delete",
    updates_hex: [
      "6c6f726f0000000000000000000000003a1db5f900044c0003000301100101000000000000000101000000000005010000010006010401020000050474657874001101040204000303000203030509030302010b010302010002010202010203024142",
      "6c6f726f0000000000000000000000008439c67300043e0002000201100101000000000000000101000000000005010000010006010401020000050474657874000e010402010002010002010502010200030241424800010201011b02020000000000000001000000000000000101010101010200000005010000010006010401020000050474657874000e010402010002010202010502010100020158",
    ],
    expected_json: "{\"text\":\"AX\"}",
  },
  {
    name: "concurrent_movable_list_insert_same_pos",
    updates_hex: [
      "6c6f726f00000000000000000000000013d953b800043e000100010110010100000000000000010100000000000501000001000601040104000003026d6c000e010402010002010002010b02010100050701050141",
      "6c6f726f000000000000000000000000a785a24400043e000100010110010200000000000000010100000000000501000001000601040104000003026d6c000e010402010002010002010b02010100050701050142",
    ],
    expected_json: "{\"ml\":[\"A\",\"B\"]}",
  },
  {
    name: "concurrent_movable_list_move_same_elem",
    updates_hex: [
      "6c6f726f000000000000000000000000a16cd5c700044a000400040110010100000000000000010100000000000501000001000601040104000003026d6c001101040204000303000403030b0e03030301000e0703050161050162050163000000",
      "6c6f726f000000000000000000000000df138a0d000444000300030110010100000000000000010100000000000501000001000601040104000003026d6c000e010402010002010002010b020103000b07030501610501620501634700010301011b0202000000000000000100000000000000010101010101040000000501000001000601040104000003026d6c000e010402010002010202010e0201010003000100",
    ],
    expected_json: "{\"ml\":[\"b\",\"a\",\"c\"]}",
  },
  {
    name: "concurrent_movable_list_set_same_elem",
    updates_hex: [
      "6c6f726f0000000000000000000000003e798f29000444000200020110010100000000000000010100000000000501000001000601040104000003026d6c000f010402040002040003030b0f020401000a07010501610000050178",
      "6c6f726f00000000000000000000000020f251b700043e000100010110010100000000000000010100000000000501000001000601040104000003026d6c000e010402010002010002010b020101000507010501614900010101011b0202000000000000000100000000000000010101010101000000000501000001000601040104000003026d6c000e010402010002010002010f02010100050100050179",
    ],
    expected_json: "{\"ml\":[\"y\"]}",
  },
]

///|
test "lorodoc seq-crdt matches Rust oracle vectors" {
  for c in RUST_ORACLE_VECTORS {
    let expected = @json.parse(c.expected_json[:]) catch {
      _ => fail("invalid expected_json for case: " + c.name)
    }

    let doc1 = LoroDoc::new()
    try! doc1.setPeerId(999UL)
    for h in c.updates_hex {
      try! doc1.import(hex_to_bytes(h))
    }
    assert_eq(doc1.toJSON(), expected)

    let doc2 = LoroDoc::new()
    try! doc2.setPeerId(1000UL)
    for h in reversed_copy(c.updates_hex) {
      try! doc2.import(hex_to_bytes(h))
    }
    assert_eq(doc2.toJSON(), expected)
  }
}
